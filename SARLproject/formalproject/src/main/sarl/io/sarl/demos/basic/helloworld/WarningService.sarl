package io.sarl.demos.basic.helloworld

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.DefaultContextInteractions
import it.polito.appeal.traci.SumoTraciConnection
import java.util.List
import de.tudresden.sumo.cmd.Vehicle
import de.tudresden.sumo.cmd.Junction
import io.sarl.core.Schedules
import io.sarl.demos.basic.helloworld.events.OBUDisconnect
import java.util.ArrayList
import java.util.HashMap;
import io.sarl.demos.basic.helloworld.events.RSUStatus
import de.tudresden.ws.container.SumoPosition2D
import kpi.Kpi

@SuppressWarnings("potential_inefficient_value_conversion", "potential_field_synchronization_problem", "unused_agent_capacity", "discouraged_reference")
agent WarningService {
	uses Lifecycle, DefaultContextInteractions, Schedules
	var conn : SumoTraciConnection
	var OBusList : List<String> = new ArrayList<String>()
	var RsusStatus = new HashMap<String, Boolean>
	var rsu_distance = 13.0
	var cyclist_range = 5.0
	
	var kpis : Kpi

	on Initialize {
		this.conn = occurrence.parameters.get(0) as SumoTraciConnection
		this.conn.runServer();
		this.conn.setOrder(1);

		this.kpis = new Kpi(this.conn)

		this.RsusStatus.put("East", false)
		this.RsusStatus.put("West", false)

		spawnElements

		run
	}

	on RSUStatus {
		if (occurrence.name.equals("East")) {
			this.RsusStatus.put("East", occurrence.status)
		} else {
			this.RsusStatus.put("West", occurrence.status)
		}
	}

	def run {
		val task = task("sumo running")	
		task.every(50) [
			this.conn.do_timestep();
			var vehicles : List<String> = this.conn.do_job_get(Vehicle.getIDList()) as List<String>
			kpis.checkKPIs();
			for (v : vehicles) {
				var veh_data = readData(v)
				var type = veh_data.get("type") as String
				if (type.contains("bus")) {
					if (!this.OBusList.contains(v)) {
						spawn(OBU, v, this.conn)
						this.OBusList.add(v)
						println(v + " ENTERED")
					}
				} else if (type.contains("bicycle-distracted")) {	
						
					var distance = veh_data.get("distance") as Double
					var speed = veh_data.get("speed") as Double
					var east_rsu = this.RsusStatus.get("East") as Boolean
					var road_id = veh_data.get("road_id") as String
					if (east_rsu && road_id.contains("i")) {
						if (distance > rsu_distance && distance < rsu_distance + cyclist_range) {
							this.conn.do_job_set(Vehicle.setSpeed(v, 0.0))
							println("Bicycle distracted entered" + distance + "RSU distance is:-" + rsu_distance + "Cyclists range is :- " + cyclist_range + "cyclists speed :-" + speed);
						}
					} else {
						if (speed == 0) {
							this.conn.do_job_set(Vehicle.setSpeed(v, 4.2)) // 4.2 - speed of bicycle set here
							println(v + "Bicycle distracted entered");
						}
					}
				}
			}

			for (k : this.OBusList) {
				var flag : boolean = false

				for (v : vehicles) {
					if (k.equals(v)) {
						flag = true
						break
					}
				}

				if (!flag) {
					println(k + " REMOVED")
					emit(new OBUDisconnect(k))
					this.OBusList.remove(k)
					break
				}
			}
		]
	}

	def spawnElements {
		spawn(Controller, this.conn)
		spawn(RSU, "East", 15.5, -10.5, this.conn) // EAST X, Y
		spawn(Camera, "CameraOne", this.conn, -15.0, 0.0, 2.0, 0.7, 4) 	// CameraName, Connection, X, Y, Size, Height, Angle
	}

	on Destroy {
		this.conn.close();
		println("Environment destroyed")

	}

	def readData(id : String) {
		var position : SumoPosition2D = this.conn.do_job_get(Vehicle.getPosition(id)) as SumoPosition2D
		var centre = this.conn.do_job_get(Junction.getPosition("0")) as SumoPosition2D
		var type : String = this.conn.do_job_get(Vehicle.getTypeID(id)) as String
		var speed : double = this.conn.do_job_get(Vehicle.getSpeed(id)) as Double
		var length : double = this.conn.do_job_get(Vehicle.getLength(id)) as Double
		var accel : double = this.conn.do_job_get(Vehicle.getAccel(id)) as Double
		var road_id : String = this.conn.do_job_get(Vehicle.getRoadID(id)) as String
		var tempx : double = Math.abs(centre.x - position.x)
		var tempy : double = Math.abs(centre.y - position.y)		
		var distance = Math.sqrt(tempx * tempx + tempy * tempy)
		distance = distance - length / 2
		var myMap : HashMap<String, Object> = newHashMap(
			'type' -> type, 
			'speed' -> speed, 
			'accel' -> accel, 
			'distance' -> distance,
			'road_id' -> road_id,
			'length' -> length
		)
		return myMap
	}
	
	def calcDeceleration(init_speed : Double, final_speed : Double, remaining_dist : Double){		
		var acc = ( (8 * remaining_dist) / ( (init_speed + final_speed) * (init_speed + final_speed) ) ) -
			( (4 * init_speed) / (init_speed + final_speed) )
		return -acc
	}
}